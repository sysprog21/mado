#!/usr/bin/env python3
"""
Generate precomputed Gaussian-style weights for the drop shadow LUT.

The curve approximates (1 - t^2)^2 * 0.92 + 0.08 sampled at 17 points
between 0 and 1 (inclusive). Values are emitted in 16.16 fixed-point so
the renderer can remain purely fixed-point.
"""

import math
import pathlib
import sys


def compute_weights(samples: int = 16) -> list[int]:
    weights = []
    for idx in range(samples + 1):
        t = idx / samples
        value = ((1.0 - t * t) ** 2) * 0.92 + 0.08
        fixed = int(round(value * 65536))  # 16.16 fixed-point
        fixed = max(0, min(fixed, 0xFFFFFFFF))
        weights.append(fixed)
    return weights


HEADER_TEMPLATE = """\
/*
 * This file is auto-generated by scripts/gen-shadow-lut.py.
 * Do not edit manually.
 */
#ifndef SHADOW_GAUSSIAN_LUT_H
#define SHADOW_GAUSSIAN_LUT_H

#include "twin.h"

static const twin_fixed_t shadow_gaussian_lut[{count}] = {{
{body}
}};

#endif /* SHADOW_GAUSSIAN_LUT_H */
"""


def emit_header(path: pathlib.Path) -> None:
    weights = compute_weights()
    lines = []
    for idx, value in enumerate(weights):
        suffix = "," if idx < len(weights) - 1 else ""
        lines.append(f"    0x{value:05x}{suffix}")
    header = HEADER_TEMPLATE.format(count=len(weights), body="\n".join(lines))
    path.write_text(header, encoding="utf-8")


def main(argv: list[str]) -> int:
    if len(argv) != 2:
        sys.stderr.write("Usage: gen-shadow-lut.py <output>\n")
        return 1
    output_path = pathlib.Path(argv[1])
    emit_header(output_path)
    return 0


if __name__ == "__main__":
    raise SystemExit(main(sys.argv))
